<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Note Compilation</title>
    <link rel="stylesheet" href="./main.css">
</head>
<body>

    <div class="navigation">
        <a href="index.html"><p>HTML</p></a>
        <a href="css.html"><p>CSS</p></a>
        <a href="javascript.html"><p>Javascript</p></a>
        <a href="express.html"><p>Express</p></a>
        <a href="react.html"><p>React</p></a>
        <a href="python.html"><p>Python</p></a>
        <a href="other.html"><p>OTHER</p></a>
    </div>

    <div class="chapter bubble">Chapter 1 - Arrays and Objects</div>
    <div class="small green bubble">
        <p>
            <span class="title highlight-red">Arrays</span><br>
            var reducer = <span class="highlight-red">array_name</span><span class="highlight-boo"><span class="highlight-green">.reduce((acc,current) => acc + current, <span class="highlight-note">[initial]</span>)</span></span> Returns the sum of values in the array <span class="highlight-note">[+ optional initial value]</span><br>
            var a = <span class="highlight-red">array_name</span><span class="highlight-green">.with(<span class="highlight-note">index,value</span>)</span> Creates a copy of array with new value at index<br>
            var a = <span class="highlight-red">array_name</span><span class="highlight-green">.flat(<span class="highlight-note">default=1</span>)</span> Spreads nested arrys to the factor specified<br>
            var spreader = <span class="highlight-yellow">new Set(<span class="highlight-red">[...spread,...arrays]</span>)</span> By spreading array contents into a set, duplicates are automatically rejected<br>
            <span class="title highlight-blue">Objects</span><br>
            const obj = <span class="highlight-yellow">Object</span>.groupBy(<span class="highlight-blue">object_name</span>, <span class="highlight-green">item => { item.name }</span>)
        </p>
    </div>

    <div class="chapter bubble">Chapter 2 - Intersection Observers</div>
    <div class="small teal bubble">
        <p>
            const <span class="highlight-orange">options</span> = { threshold: 1 , rootMargin: "0px 0px -100px 0px" };<br><br>

            const <span class="highlight-orange">observerr</span> = new IntersectionObserver(function(<span class="highlight-red">entries,appear</span>) {<br>
                <span class="highlight-red">entries</span>.forEach(<span class="highlight-green">entry</span> => {<br>
                    if(!<span class="highlight-green">entry</span>.isIntersecting) { <span class="highlight-blue">return</span> } else {<br>
                        <span class="highlight-green">entry</span>.target.classList.add();<br>
                        <span class="highlight-red">appear</span>.unobserve(<span class="highlight-green">entry</span>.target); }<br>
                 });<br>
                }, <span class="highlight-orange">options</span>);<br><br>

            const <span class="highlight-orange">hiddenElements</span> = document.querySelectorAll(...);<br>
            <span class="highlight-orange">hiddenElements</span>.forEach(<span class="highlight-green">fader</span> => {<span class="highlight-orange">observer</span>.observe(<span class="highlight-green">fader</span>)} );
        </p>
    </div>

    <div class="chapter bubble">Chapter 3 - Cookies & Process Environments</div>
    <div class="tiny blue bubble">
        <p>
            document.cookie = "(key)=(value) ; <span class="highlight-blue">expires=(date)</span> ; path=(/path/here)"<br><br>
            <span class="highlight-note">// Cookies do not have a delete function but can have the expiration updated to an already passed date for an instakill</span><br><br>
            require("dotenv").config(); const http = require('http');<br>
            const port = parseInt(process.env.PORT) || 5000;<br>
            http<span class="highlight-orange">.createServer(<span class="highlight-blue">(req, res) => { res.writeHead(200, {'Content-Type':'text/plain'} ) }</span>)</span>
       </p>
    </div>

    <div class="chapter bubble">Chapter 4 - Infinite Scrolling</div>
    <div class="small purple bubble">
        <p>
            const <span class="highlight-green">url</span> = 'path/to/be/manipulated/'; <span class="highlight-note">// This path must produce an image whenever a number is attached to the end of it</span><br>
            const <span class="highlight-green">container</span> = document.querySelector('.container');<br><br>
            function <span class="highlight-purple">getRandomNumber() </span>{<span class="highlight-note">// return a random integer</span>}<br><br>
            function <span class="highlight-purple">loadImages(<span class="highlight-red">num</span>) {</span><br>
                let <span class="highlight-green">i</span> = 0;<br>
                while(<span class="highlight-green">i</span> <= <span class="highlight-red">num</span> && <span class="highlight-red">num</span> > 0) {<br>
                    const <span class="highlight-green">img</span> = document.createElement('img');<br>
                    <span class="highlight-green">img</span>.src = `${<span class="highlight-green">url</span>}${<span class="highlight-purple">getRandomNumber()</span>}`;<br>
                    <span class="highlight-green">container</span>.appendChild(<span class="highlight-green">img</span>); <span class="highlight-green">i++</span> }<br>
                    <span class="highlight-purple">}</span><br><br>
            window.addEventListener('scroll', () => { if (window.scrollY + window.innerHeight >= document.documentElement.scrollHeight) { <span class="highlight-purple">loadImages()</span> } })<br>
        </p>
    </div>

    <div class="chapter bubble">Chapter 5 - Maps and Sets</div>
    <div class="big orange bubble">
        <p>
            <span class="highlight-green title">Maps</span><br>
            const <span class="highlight-green">myMap</span> = <span class="highlight-red">new</span> <span class="highlight-green">Map()</span> Initialize new map object that only accepts key-value pairs<br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.get(</span>key<span class="highlight-orange">)</span> <span class="highlight-blue">return</span> value associated with key<br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.has(</span>key<span class="highlight-orange">)</span> <span class="highlight-blue">return</span> boolean<br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.set(</span>key,value<span class="highlight-orange">)</span><br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.delete(</span>key<span class="highlight-orange">)</span><br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.keys()</span><br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.values()</span><br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.entries()</span> <span class="highlight-blue">return</span> all key-value pairs<br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.size()</span><br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.clear()</span><br>
            <span class="highlight-note">// Chain methods together: map.set(x,y).set(x,y).set(x,y)</span><br>

            <span class="highlight-yellow title">Sets</span><br>
            const <span class="highlight-yellow">mySet</span> = <span class="highlight-red">new</span> <span class="highlight-yellow">Set()</span> Initialize new set that only accepts unique atomic values<br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.add(</span>key<span class="highlight-orange">)</span> Attempting to add a value that already exists will fail<br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.has(</span>value<span class="highlight-orange">)</span> <span class="highlight-blue">return</span> boolean<br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.delete(</span>value<span class="highlight-orange">)</span><br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.size()</span><br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.clear()</span><br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.forEach(</span>value<span class="highlight-orange"> => { })</span><br>
            <span class="highlight-note">// Chain methods together: map.set(x,y).set(x,y).set(x,y)</span><br>

            <span class="highlight-purple title">Hash Maps</span><br>
            <span class="highlight-note"> /<br>
                i. Maximum of 1 value per key<br>
                ii. Separate chaining elevates indexes to linked-lists within arrays<br>
                /<br>
                class <span class="highlight-purple">Map</span> {<br>
                    constructor(<span class="highlight-purple">size</span>) { this.hashMap = new Array(<span class="highlight-purple">size</span>).fill(*).map(() => new Linkedlist()) }<br><br>
                    hash(<span class="highlight-purple">key</span>) {<br>
                        let <span class="highlight-red">hashCode</span> = '';<br>
                        for (<span class="highlight-note">i in loop</span>) { <span class="highlight-red">hashCode</span> += <span class="highlight-red">hashCode</span> + <span class="highlight-purple">key</span>.charCodeAt(<span class="highlight-note">i</span>) }<br>
                        return <span class="highlight-red">hashCode</span> }<br><br>
                    assign(<span class="highlight-purple">key,value</span>) {<br> 
                        const <span class="highlight-red">arrayIndex</span> = this.hash(<span class="highlight-purple">key</span>);<br>
                        this.hashMap[<span class="highlight-red">arrayIndex</span>] = <span class="highlight-purple">value</span> }<br><br>
                    retrieve(<span class="highlight-purple">key</span>) {<br> 
                        const <span class="highlight-red">arrayIndex</span> = this.hash(<span class="highlight-purple">key</span>);<br>
                        return this.hashMap[<span class="highlight-red">arrayIndex</span>] }<br><br>
                }
            </span>
        </p>
    </div>

    <div class="chapter bubble">Chapter 6 - Event Listeners</div>
    <div class="medium grey bubble">
        <p>
            document.addEventListener("click", <span class="highlight-green">e</span> => {<br>
                if (<span class="highlight-green">e</span>.target.matches("div") { <span class="highlight-note"> ... </span> })<br>
            }); <span class="highlight-note"> // Delegate all event listeners to the desired outermost body or document</span><br><br>
            <span class="highlight-green title">Disappearing Navbar</span><br><br>
            const <span class="highlight-red">body</span> = document.body;<br>
            let <span class="highlight-red">lastScroll</span> = 0;<br><br>
            window.addEventListener("scroll", () => {<br><br>
                const <span class="highlight-green">currentScroll</span> = window.pageYOffSet;<br><br>
                if (<span class="highlight-green">currentScroll</span> <= 0) { <span class="highlight-red">body</span>.classList.remove('scroll-up') };<br><br>
                if (<span class="highlight-green">currentScroll</span> > <span class="highlight-red">lastScroll</span> && !<span class="highlight-red">body</span>.classList.contains('scroll-down')) {<br>
                    <span class="highlight-red">body</span>.classList.remove('scroll-up'); <span class="highlight-red">body</span>.classList.add('scroll-down') };<br><br>
                    if (<span class="highlight-green">currentScroll</span> < <span class="highlight-red">lastScroll</span> && <span class="highlight-red">body</span>.classList.contains('scroll-down')) {<br>
                        <span class="highlight-red">body</span>.classList.remove('scroll-down'); <span class="highlight-red">body</span>.classList.add('scroll-up') };<br><br>
                        <span class="highlight-red">lastScroll</span> = <span class="highlight-green">currentScroll</span> });<br>
        </p>
    </div>
    <div class="chapter bubble">Chapter 7 - Graph Traversal</div>
    <div class="medium blue bubble">
        <p>
            <span class="highlight-orange title">Breadth First Search</span><br>
            USING A <span class="highlight-orange">QUEUE</span>:<br>
            <span class="highlight-orange">i.</span> Check starting Node, add children to <span class="highlight-orange">queue</span> if not visited already.<br>
            <span class="highlight-orange">ii.</span> Shift() <span class="highlight-orange">queue</span>, check the returned value, add children to <span class="highlight-orange">queue</span> if not visited already.<br>
            <span class="highlight-orange">iii.</span> Continue until <span class="highlight-orange">queue</span> is empty.<br>
            <span class="highlight-blue title">Depth First Search</span><br>
            USING A <span class="highlight-blue">STACK</span>:<br>
            <span class="highlight-blue">i.</span> Check starting Node, add children to <span class="highlight-blue">stack</span> if not already visited.<br>
            <span class="highlight-blue">iia.</span> Pop() stack, if children do exist and have not been visited, add them to <span class="highlight-blue">stack</span>.<br>
            <span class="highlight-blue">iib.</span> If no children exist, pop() <span class="highlight-blue">stack</span>.<br>
            <span class="highlight-purple title">Dijkstra's Algorithm</span><br>
            <span class="highlight-note tiny-font">Requires edges to have positive value weighted costs</span><br>
            <span class="highlight-purple">i.</span> Starting at source node, check for the next node with the shortest distance and move to it.<br>
            <span class="highlight-purple">ii</span> Keep track of shortest distances, updating result as necessary and marking nodes as visited.<br>
            <span class="highlight-purple">iii.</span> Continue until all nodes have been visited and / or the destination node was found.<br>
            <span class="highlight-purple">iv.</span> Return the result which will be the sum of all the shortest distances.<br><br>
            <span class="highlight-blue">PREORDER</span> nodes are added to 'visited' list <span class="highlight-blue">before</span> being placed in a stack.<br>
            <span class="highlight-blue">POSTORDER</span> nodes are added to 'visited' list <span class="highlight-blue">after</span> being placed in a stack.<br>
        </p>
    </div>
    <div class="chapter bubble">Chapter 8 - Tips and Tricks</div>
    <div class="small teal bubble">
        <p>
            <span class="highlight-blue">document.querySelectorAll(<span class="highlight-note">'p.class,div#id'</span>)</span><br>
            <span class="highlight-blue">document.designMode = 'on'</span> Enables in-window custom text editing without open editor<br>
            <span class="highlight-blue">Math.floor(Math.random()*0xffffff).toString(16)</span> Produces a random color code<br>
            <span class="highlight-blue">navigator.clipboard.writeText(<span class="highlight-red">e</span>)</span> Copies <span class="highlight-red">e</span> to user's clipboard<br>
        </p>
    </div>
</body>
</html>