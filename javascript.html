<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Note Compilation</title>
    <link rel="stylesheet" href="./main.css">
</head>
<body>

    <div class="navigation">
        <a href="index.html"><p>HTML</p></a>
        <a href="css.html"><p>CSS</p></a>
        <a href="javascript.html"><p>Javascript</p></a>
        <a href="express.html"><p>Express</p></a>
        <a href="react.html"><p>React</p></a>
        <a href="python.html"><p>Python</p></a>
        <a href="other.html"><p>OTHER</p></a>
    </div>

    <div class="chapter bubble">Chapter 1 - Infinite Scrolling</div>
    <div class="medium purple bubble">
        <p>
            const <span class="highlight-green">url</span> = 'path/to/be/manipulated/'; <span class="highlight-note">**</span><br>
            const <span class="highlight-green">container</span> = document.querySelector('.container');<br><br>
            function <span class="highlight-green">getRandomNumber() </span>{...}<br><br>
            function <span class="highlight-green">loadImages(<span class="highlight-red">num</span><span class="highlight-note">=#</span>)</span> {<br>
                let <span class="highlight-green">i</span> = 0;<br>
                while(<span class="highlight-green">i</span> <= <span class="highlight-red">num</span>) {<br>
                    const <span class="highlight-green">img</span> = document.createElement('img');<br>
                    <span class="highlight-green">img</span>.src = `${<span class="highlight-green">url</span>}${<span class="highlight-green">getRandomNumber()</span>}`;<br>
                    <span class="highlight-green">container</span>.appendChild(<span class="highlight-green">img</span>);<br>
                    <span class="highlight-green">i++</span> }}<br><br>
            window.addEventListener('scroll', () => {<br>
                if (window.scrollY + window.innerHeight >= document.documentElement.scrollHeight) { <span class="highlight-green">loadImages()</span> }<br>
            })<br><br>
            <span class="highlight-note">// ** The end of this path must produce an image when a number is appended to the end of it</span>
        </p>
    </div>


    <div class="chapter bubble">Chapter 2 - Intersection Observers</div>
    <div class="medium teal bubble">
        <p>
            const <span class="highlight-orange">options</span> = { threshold: 1 , rootMargin: "0px 0px -100px 0px" };<br><br>

            const <span class="highlight-orange">appear</span> = new IntersectionObserver(function(<span class="highlight-red">entries,appear</span>) {<br>
                <span class="highlight-red">entries</span>.forEach(<span class="highlight-green">entry</span> => {<br>
                    if(!<span class="highlight-green">entry</span>.isIntersecting) { return } else {<br>
                        <span class="highlight-green">entry</span>.target.classList.add();<br>
                        <span class="highlight-red">appear</span>.unobserve(<span class="highlight-green">entry</span>.target); }<br>
                 });<br>
                }, <span class="highlight-orange">options</span>);<br><br>

            const <span class="highlight-orange">faders</span> = document.querySelectorAll();<br><br>

            <span class="highlight-orange">faders</span>.forEach(<span class="highlight-green">fader</span> => {<br>
                <span class="highlight-orange">appear</span>.observe(<span class="highlight-green">fader</span>)<br>
            });
        </p>
    </div>


    <div class="chapter bubble">Chapter 3 - Stripe</div>
    <div class="small brown bubble">
        <p>
            const <span class="highlight-red">stripe</span> = require("stripe")(process.ENV.STRIPE_PRIVATE_KEY);<br>
            const <span class="highlight-green">button</span> = document.getElementById('checkout');<br><br>

            <span class="highlight-green">button</span>.addEventListener("click", () => {<br>
                <span class="highlight-orange">fetch</span>('/checkout/path', {<br>
                    method: POST,<br>
                    headers: {"Content-Type":"app/json"},<br>
                    body: JSON.stringify({items: [ {id: #, quantity: #} ]})<br>
                })<br>
            }).then().catch() => ...
        </p>
    </div>


    <div class="chapter bubble">Chapter 4 - Cookies</div>
    <div class="small blue bubble">
        <p>
            document.cookie = "(key)=(value) ; <span class="highlight-green">expires=(date)</span> ; <span class="highlight-red">path=(/path/here)</span>"<br><br>
            <span class="highlight-note">// Cookies do not have a delete function but can have the expiration updated to a past date to induce instant deletion</span><br>
        </p>
    </div>

    <div class="chapter bubble">Chapter 5 - Arrays and Objects</div>
    <div class="big green bubble"></div>

    <div class="chapter bubble">Chapter 6 - Maps and Sets</div>
    <div class="giant orange bubble">
        <p>
            <span class="highlight-green title">Maps</span><br>
            const <span class="highlight-green">myMap</span> = <span class="highlight-red">new</span> <span class="highlight-green">Map()</span> Initialize new map object that only accepts key-value pairs<br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.get(</span>key<span class="highlight-orange">)</span> <span class="highlight-blue">return</span> value associated with key<br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.has(</span>key<span class="highlight-orange">)</span> <span class="highlight-blue">return</span> boolean<br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.set(</span>key,value<span class="highlight-orange">)</span><br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.delete(</span>key<span class="highlight-orange">)</span><br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.keys()</span><br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.values()</span><br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.entries()</span> <span class="highlight-blue">return</span> all key-value pairs<br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.size()</span><br>
            <span class="highlight-green">myMap</span><span class="highlight-orange">.clear()</span><br>
            <span class="highlight-note">// Chain methods together: map.set(x,y).set(x,y).set(x,y)</span><br>

            <span class="highlight-yellow title">Sets</span><br>
            const <span class="highlight-yellow">mySet</span> = <span class="highlight-red">new</span> <span class="highlight-yellow">Set()</span> Initialize new set that only accepts unique atomic values<br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.add(</span>key<span class="highlight-orange">)</span> Attempting to add a value that already exists will fail<br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.has(</span>value<span class="highlight-orange">)</span> <span class="highlight-blue">return</span> boolean<br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.delete(value)</span><br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.size()</span><br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.clear()</span><br>
            <span class="highlight-yellow">mySet</span><span class="highlight-orange">.forEach(value => { })</span><br>
            <span class="highlight-note">// Chain methods together: map.set(x,y).set(x,y).set(x,y)</span><br>

            <span class="highlight-purple title">Hash Maps</span><br>
            <span class="highlight-note"> /<br>
                i. Maximum of 1 value per key<br>
                ii. Separate chaining elevates indexes to linked-lists within arrays<br>
                /<br>
                class <span class="highlight-purple">Map</span> {<br>
                    constructor(<span class="highlight-purple">size</span>) { this.hashMap = new Array(<span class="highlight-purple">size</span>).fill(*).map(() => new Linkedlist()) }<br><br>
                    hash(<span class="highlight-purple">key</span>) {<br>
                        let <span class="highlight-red">hashCode</span> = '';<br>
                        for (<span class="highlight-note">i in loop</span>) { <span class="highlight-red">hashCode</span> += <span class="highlight-red">hashCode</span> + <span class="highlight-purple">key</span>.charCodeAt(<span class="highlight-note">i</span>) }<br>
                        return <span class="highlight-red">hashCode</span> }<br><br>
                    assign(<span class="highlight-purple">key,value</span>) {<br> 
                        const <span class="highlight-red">arrayIndex</span> = this.hash(<span class="highlight-purple">key</span>);<br>
                        this.hashMap[<span class="highlight-red">arrayIndex</span>] = <span class="highlight-purple">value</span> }<br><br>
                    retrieve(<span class="highlight-purple">key</span>) {<br> 
                        const <span class="highlight-red">arrayIndex</span> = this.hash(<span class="highlight-purple">key</span>);<br>
                        return this.hashMap[<span class="highlight-red">arrayIndex</span>]}<br><br>
                }
            </span>
        </p>
    </div>
    
</body>
</html>